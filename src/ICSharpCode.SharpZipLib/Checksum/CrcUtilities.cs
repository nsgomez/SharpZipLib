using System.Runtime.CompilerServices;

namespace ICSharpCode.SharpZipLib.Checksum
{
	internal static class CrcUtilities
	{
		/// <summary>
		/// The number of slicing lookup tables to generate.
		/// </summary>
		internal const int SlicingDegree = 16;

		/// <summary>
		/// Generates multiple CRC lookup tables for a given polynomial, stored
		/// in a linear array of uints. The first block (i.e. the first 256
		/// elements) is the same as the byte-by-byte CRC lookup table. 
		/// </summary>
		/// <param name="polynomial">The generating CRC polynomial</param>
		/// <param name="isReversed">Whether the polynomial is in reversed bit order</param>
		/// <returns>A linear array of 256 * <see cref="SlicingDegree"/> elements</returns>
		/// <remarks>
		/// This table could also be generated as a rectangular array, but the
		/// JIT compiler generates slower code than if we use a linear array.
		/// Known issue, see: https://github.com/dotnet/runtime/issues/30275
		/// </remarks>
		internal static uint[] GenerateSlicingLookupTable(uint polynomial, bool isReversed)
		{
			var table = new uint[256 * SlicingDegree];
			uint one = isReversed ? 1 : (1U << 31);

			for (int i = 0; i < 256; i++)
			{
				uint res = (uint)(isReversed ? i : i << 24);
				for (int j = 0; j < SlicingDegree; j++)
				{
					for (int k = 0; k < 8; k++)
					{
						if (isReversed)
						{
							res = (res & one) == 1 ? polynomial ^ (res >> 1) : res >> 1;
						}
						else
						{
							res = (res & one) != 0 ? polynomial ^ (res << 1) : res << 1;
						}
					}

					table[(256 * j) + i] = res;
				}
			}

			return table;
		}

		/// <summary>
		/// Mixes the first four bytes of input with <paramref name="checkValue"/>
		/// using normal ordering before calling <see cref="UpdateDataCommon"/>.
		/// </summary>
		/// <param name="input">Pointer to data to checksum</param>
		/// <param name="crcTable">Pointer to table to use for slicing-by-16 lookup</param>
		/// <param name="checkValue">Checksum state before this update call</param>
		/// <returns>A new unfinalized checksum value</returns>
		/// <seealso cref="UpdateDataForReversedPoly"/>
		/// <remarks>
		/// Assumes input[0]..input[15] are valid array indexes.
		/// For performance reasons, this must be checked by the caller.
		/// </remarks>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static unsafe uint UpdateDataForNormalPoly(byte* input, uint* crcTable, uint checkValue)
		{
			byte x1 = (byte)((byte)(checkValue >> 24) ^ input[0]);
			byte x2 = (byte)((byte)(checkValue >> 16) ^ input[1]);
			byte x3 = (byte)((byte)(checkValue >> 8) ^ input[2]);
			byte x4 = (byte)((byte)checkValue ^ input[3]);

			return UpdateDataCommon(input, crcTable, x1, x2, x3, x4);
		}

		/// <summary>
		/// Mixes the first four bytes of input with <paramref name="checkValue"/>
		/// using reflected ordering before calling <see cref="UpdateDataCommon"/>.
		/// </summary>
		/// <param name="input">Pointer to data to checksum</param>
		/// <param name="crcTable">Pointer to table to use for slicing-by-16 lookup</param>
		/// <param name="checkValue">Checksum state before this update call</param>
		/// <returns>A new unfinalized checksum value</returns>
		/// <seealso cref="UpdateDataForNormalPoly"/>
		/// <remarks>
		/// Assumes input[0]..input[15] are valid array indexes.
		/// For performance reasons, this must be checked by the caller.
		/// </remarks>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static unsafe uint UpdateDataForReversedPoly(byte* input, uint* crcTable, uint checkValue)
		{
			byte x1 = (byte)((byte)checkValue ^ input[0]);
			byte x2 = (byte)((byte)(checkValue >>= 8) ^ input[1]);
			byte x3 = (byte)((byte)(checkValue >>= 8) ^ input[2]);
			byte x4 = (byte)((byte)(checkValue >>= 8) ^ input[3]);

			return UpdateDataCommon(input, crcTable, x1, x2, x3, x4);
		}

		/// <summary>
		/// A shared method for updating an unfinalized CRC checksum using slicing-by-16.
		/// </summary>
		/// <param name="input">Pointer to data to checksum</param>
		/// <param name="crcTable">The table to use for slicing-by-16 lookup</param>
		/// <param name="x1">First byte of input after mixing with the old CRC</param>
		/// <param name="x2">Second byte of input after mixing with the old CRC</param>
		/// <param name="x3">Third byte of input after mixing with the old CRC</param>
		/// <param name="x4">Fourth byte of input after mixing with the old CRC</param>
		/// <returns>A new unfinalized checksum value</returns>
		/// <remarks>
		/// Because most processors running C# have some kind of instruction-level
		/// parallelism, the order of XOR operations can affect performance. This
		/// ordering assumes that the assembly code generated by the just-in-time
		/// compiler will emit a bunch of arithmetic operations for checking array
		/// bounds. Then it opportunistically XORs a1 and a2 to keep the processor
		/// busy while those other parts of the pipeline handle the range check
		/// calculations.
		/// </remarks>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static unsafe uint UpdateDataCommon(byte* input, uint* crcTable, byte x1, byte x2, byte x3, byte x4)
		{
			uint result;
			uint a1 = crcTable[x1 + 3840UL] ^ crcTable[x2 + 3584UL];
			uint a2 = crcTable[x3 + 3328UL] ^ crcTable[x4 + 3072UL];

			result = crcTable[input[4] + 2816UL];
			result ^= crcTable[input[5] + 2560UL];
			a1 ^= crcTable[input[9] + 1536UL];
			result ^= crcTable[input[6] + 2304UL];
			result ^= crcTable[input[7] + 2048UL];
			result ^= crcTable[input[8] + 1792UL];
			a2 ^= crcTable[input[13] + 512UL];
			result ^= crcTable[input[10] + 1280UL];
			result ^= crcTable[input[11] + 1024UL];
			result ^= crcTable[input[12] + 768UL];
			result ^= a1;
			result ^= crcTable[input[14] + 256UL];
			result ^= crcTable[input[15]];
			result ^= a2;

			return result;
		}
	}
}
